package com.dal.CalculatorD;

/**
 * Represents a fraction, and includes various operations (addition,
 * subtraction, and the like) to assist in mathematical computations.
 * Some technical details:
 * <ul>
 * <li>
 * <code>Fractions</code> are represented by a numerator and a denominator
 * </li>
 * <li>
 * Numerators, denominators are stored in int variables
 * </li>
 * <li>
 * Fractions are immutable (much like Java's <code>String</code> class)
 * </li>
 * </ul>
 * @author Dustin Leavins
 */
public class Fraction {
	private final int numerator;
	private final int denominator;
	
	/**
	 * Takes a string in the format of "X.Y" (where X and Y are
	 * base-10 numbers) and gives a <code>Fraction</code> in return.
	 * Technical note:  unlike the other constructor available for this
	 * class, this does not throw ArithmeticException.  You can't
	 * specify a denominator of 0 using a string.
	 * @param stringContainingNumber the input string!
	 * @return <code>Fraction</code> object
	 */
	public Fraction(String stringContainingNumber) {
		char tempCharacter;
		boolean readingValue = true;
		boolean readingFractionalPart = false;
		StringBuffer sbuffer = new StringBuffer(stringContainingNumber);
		int num = 0;
		int denom = 1;
		boolean negativeNumber = false;

		// Many strings don't end properly.  In these cases, the
		// following while loop throws an ArrayOutOfBounds exception.
		// This is a quick fix for those cases.
		sbuffer.append("\n");


		while (readingValue) {
			tempCharacter = sbuffer.charAt(0);
			sbuffer.deleteCharAt(0);

			switch (tempCharacter) {
				case('0'):
				case('1'):
				case('2'):
				case('3'):
				case('4'):
				case('5'):
				case('6'):
				case('7'):
				case('8'):
				case('9'):
					num = (num * 10) + (tempCharacter - '0');
					if (readingFractionalPart) {
						denom = (denom * 10);
					}
					
					break;
				case('.'):
					readingFractionalPart = true;
					break;
				case('-'):
					if ((num == 0) || (denom == 1)) {
						negativeNumber = true;	
					}

					break;
				default:
					readingValue = false;
					break;
			}
		}

		if (negativeNumber) {
			num *= -1;
		}

		this.numerator = num;
		this.denominator = denom;
	}

	/**
	 * Takes a numerator and denominator and returns a 
	 * <code>Fraction</code>.
	 * @param numerator
	 * @param denominator
	 * @throws ArithmeticException When (denominator == 0) is true!
	 */
	public Fraction(int numerator, int denominator) throws ArithmeticException{
		if (denominator == 0) {
			throw new ArithmeticException("Fraction cannot have denominator equal to 0");
		}
		else if (denominator < 0) {
			denominator *= -1;
			numerator *= -1;
		}
		
		this.numerator = numerator;
		this.denominator = denominator;
	}

	/**
	 * :-)
	 * @return numerator of this <code>Fraction</code>
	 */
	public int getNumerator() {
		return numerator;
	}

	/**
	 * (-:
	 * @return denominator of this <code>Fraction</code>
	 */
	public int getDenominator() {
		return denominator;
	}
	
	/**
	 * Returns the equivalent floating point value of this
	 * <code>Fraction</code>.  Beware rounding errors!
	 * @return double value
	 */
	public double doubleValue() {
		return (1.0 * numerator) / (1.0 * denominator);
	}
	
	/**
	 * Adds <code>f</code> to this <code>Fraction</code>.
	 * @param f <code>Fraction</code> to add.
	 * @return sum
	 */
	public Fraction add(Fraction f) {
		Fraction returnFraction;
		int x = 0;
		int y = 0;
		int returnNumerator = 0;
		int returnDenominator = this.denominator * f.getDenominator();
		
		x = this.numerator * f.getDenominator();
		y = f.getNumerator() * this.denominator;
		
		returnNumerator = x + y;
		
		returnFraction = new Fraction(returnNumerator, returnDenominator);
		
		return returnFraction;
	}
	
	public Fraction negative() {
		return new Fraction(this.numerator * -1, this.denominator);
	}
	
	public Fraction subtract(Fraction f) {
		return this.add(f.negative());
	}
	
	public Fraction multiply(Fraction f) {
		int returnNumerator = this.numerator * f.getNumerator();
		int returnDenominator = this.denominator * f.getDenominator();
		return new Fraction(returnNumerator, returnDenominator);
	}
	
	public Fraction inverse() throws ArithmeticException {
		return new Fraction(this.denominator, this.numerator);
	}
	
	public Fraction divide(Fraction f) throws ArithmeticException {
		return this.multiply(f.inverse());
	}
	
	public String toString() {
		String returnString;
		
		if (denominator == 1) {
			returnString = String.valueOf(numerator);
		}
		else {
			returnString = String.valueOf(this.doubleValue());
		}
		
		return returnString;
	}

	public boolean equals(Object o){
		Fraction f;
		if (o instanceof Fraction) {
			f = (Fraction) o;
		}
		else {
			return false;
		}

		if (this.numerator == f.getNumerator() && this.denominator == f.getDenominator()) {
			return true;
		}
		else {
			return false;
		}

	}

	public static Fraction zero() {
		return new Fraction(0,1);
	}
}
